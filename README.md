# Java虚拟机

转载自：[JVM调优总结 - Andrew.Zhou - 博客园 (cnblogs.com)](https://www.cnblogs.com/andy-zhou/p/5327288.html)

### JVM虚拟机组成

<font color='red'>`运行时数据区`、`类装载子系统`、`字节码执行引擎`</font>
其中`运行时数据区`包含：堆、栈、本地方法栈、元空间、程序计数器

### 堆与栈

![image-20210425152806432](README.assets/image-20210425152806432.png)

### 栈是运行时的单位，而堆是存储的单位。

栈解决程序的运行问题，即程序如何执行，或者说如何处理数据；堆解决的是数据存储的问题，即数据怎么放、放在哪儿。

在Java中一个线程就会相应有一个线程栈与之对应，这点很容易理解，因为不同的线程执行逻辑有所不同，因此需要一个独立的线程栈。而堆则是所有线程共享的。栈因为是运行单位，因此里面存储的信息都是跟当前线程（或程序）相关信息的。包括局部变量、程序运行状态、方法返回值等等；而堆只负责存储对象信息。

### 为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？

第一，从软件设计的角度看，<font color='red'>**栈代表了处理逻辑，而堆代表了数据**</font>。这样分开，使得处理逻辑更为清晰。分而治之的思想。这种隔离、模块化的思想在软件设计的方方面面都有体现。

第二，堆与栈的分离，使得<font color='red'>**堆中的内容可以被多个栈共享（也可以理解为多个线程访问同一个对象）**</font>。这种共享的收益是很多的。一方面这种共享提供了一种有效的数据交互方式(如：共享内存)，另一方面，堆中的共享常量和缓存可以被所有栈访问，节省了空间。

第三，栈因为运行时的需要，比如保存系统运行的上下文，需要进行地址段的划分。由于<font color='red'>**栈只能向上增长**</font>，因此就会限制住栈存储内容的能力。而堆不同，堆中的对象是可以<font color='red'>**根据需要动态增长**</font>的，因此栈和堆的拆分，使得动态增长成为可能，相应栈中只需记录堆中的一个地址即可。

第四，<font color='red'>**面向对象就是堆和栈的完美结合**</font>。其实，面向对象方式的程序与以前结构化的程序在执行上没有任何区别。但是，面向对象的引入，使得对待问题的思考方式发生了改变，而更接近于自然方式的思考。当我们把对象拆开，你会发现，<font color='red'>**对象的属性其实就是数据，存放在堆中；而对象的行为（方法），就是运行逻辑，放在栈中**</font>。我们在编写对象的时候，其实即编写了数据结构，也编写的处理数据的逻辑。不得不承认，面向对象的设计，确实很美。

